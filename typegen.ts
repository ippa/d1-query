import {$} from "bun";
import pluralize from "pluralize";

// console.log(pluralize.singular("users"));
// process.exit(0);

const ignoreTables = [
  "sqlite_sequence",
  "d1_migrations",
  "_cf_KV",
  "sqlite_schema",
  "sqlite_temp_schema",
];

interface TableInfoRow {
  cid: number;
  name: string;
  type: "TIMESTAMP" | "INTEGER" | "TEXT" | "REAL" | "BLOB";
  notnull: number;
  dflt_value: any;
  pk: number;
}

type D1ListRow = {
  uuid: string;
  name: string;
  version: number;
  created_at?: string;
};

interface TableListRow {
  schema: string;
  name: string;
  type: string; // "table" | "view" | "index" | "trigger"
  ncol: number; // number of columns
  wr: boolean; // "without rowid" or not
  strict: boolean;
}

const D1TableTypeToTypeScriptType = {
  TIMESTAMP: "string",
  INTEGER: "number",
  TEXT: "string",
  REAL: "number",
  BLOB: ArrayBuffer,
};

function capitalize(string: string): string {
  return string[0].toUpperCase() + string.slice(1).toLocaleLowerCase();
}

async function sql<T>(dbName: string, sql: string) {
  const local = true;
  const json = await $`wrangler d1 execute ${dbName} ${
    local ? "--local" : ""
  } --command '${sql}' --json`.json();
  return json[0] as T;
}

let tableNameCache = {};
async function getTableNames(dbName: string): Promise<Array<string>> {
  const tableList = await sql<{results: TableListRow[]}>(dbName, "pragma table_list");
  const tableNames = tableList.results
    .filter((table) => !ignoreTables.includes(table.name))
    .map((table) => table.name);

  if (tableNameCache[dbName]) return tableNameCache[dbName];
  tableNameCache[dbName] = tableNames;
  return tableNames;
}

const dblist = (await $`wrangler d1 list --json`.json()) as Array<D1ListRow>;
console.info(`Found ${dblist.length} databases: ${dblist.map((db) => db.name).join(", ")}`);

const out: Array<string> = [];
out.push(`// DON'T EDIT - Generated by d1-query typegen.ts on ${new Date().toISOString()}`);

// Generate types for column in each table
for await (const db of dblist) {
  const dbName = db.name;

  try {
    const tableNames = await getTableNames(dbName);
    const lines = await generateTypesForDb(dbName, tableNames);
    out.push(lines.join("\n"));
  } catch (e) {
    console.error(`Error when querying db "${dbName}" with wrangler, skipping`, e.message);
  }
}

// Generate types for each database
out.push(`export interface Database {`);
for await (const db of dblist) {
  const dbName = db.name;

  try {
    const tableNames = await getTableNames(dbName);
    out.push(`  ${dbName}: {`);
    for await (const tableName of tableNames) {
      const typeName = capitalize(pluralize.singular(tableName));
      out.push(`     ${tableName}: ${typeName};`);
    }
    out.push("  }");
  } catch (e) {
    console.error(`Error when querying db "${dbName}" with wrangler, skipping`, e.message);
  }
}
out.push("}");

console.log(out.join("\n"));

// const path = `${db.name}-${db.version}-types.d.ts`;
const path = "./d1-query-types.ts";
Bun.write(path, out.join("\n"));
console.info(`Wrote ${out.length} lines to ${path}`);

async function generateTypesForDb(
  dbName: string,
  tableNames: Array<string>
): Promise<Array<string>> {
  const out: Array<string> = [];

  try {
    for await (const tableName of tableNames) {
      const typeName = capitalize(pluralize.singular(tableName));

      out.push(`export interface ${typeName} {`);
      const cmd = `pragma table_info(${tableName})`;
      const info = await sql<{results: TableInfoRow[]}>(dbName, cmd);
      info.results.forEach((row) => {
        const optional = row.notnull !== 1 && row.pk !== 1;
        out.push(`  ${row.name}${optional ? "?" : ""}: ${D1TableTypeToTypeScriptType[row.type]};`);
      });
      out.push("}");
    }
  } catch (e) {
    console.error(e);
    return [];
  }
  return out;
}
